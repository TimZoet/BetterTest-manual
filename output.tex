Out of the box BetterTest supports exporting your test results as JSON or XML. You can also define your own classes to support different formats.

The JSON and XML output files pretty much have the same layout. Because of that, the remainder of this section will use the JSON format in all examples and descriptions.

\subsection{Directory Structure}
\label{section:output:dir}

By default, all output files are placed in a subfolder named \code{suiteName.dir} next to the executable. At the root of the output folder, a suite file named \code{suite.(json|xml)} is created. This file contains some general information about the test suite and a list of all tests, with some additional information per test.

For each unit test, a folder with the test's name is created. Inside of this folder, each time the suite is run (and the test is not filtered out) a file named \code{unit\_\#\#\#\#\#\#\#\#.(json|xml)} is generated. This file contains all test results. The index is padded to 8 digits to allow easy lexicographical sorting of filenames.

As an example, running the program from Listing~\ref{lst:output:dir1} several times should result in the output files as shown in Listing~\ref{lst:output:dir2}:

\lstinputlisting[caption={Example program.}, label={lst:output:dir1}]{snippets/dir_structure.cpp}

\lstinputlisting[caption={Expected output.}, label={lst:output:dir2}]{snippets/dir_structure.txt}

\subsection{Suite File}
\label{section:output:suite}

Listing~\ref{lst:output:suite} shows the JSON specification of the suite file.

First, there is some information describing the test \code{suite}:

\begin{itemize}
\item \code{dateCreated}: Date and time at which this suite was first run.
\item \code{dateLastRun}: Date and time at which any tests in this suite were last run.
\item \code{name}: Name of the suite.
\item \code{passing}: Set to true only if all tests are passing.
\item \code{runIndex}: Index of the last run.
\item \code{version}: BetterTest version with which this file was last written.
\end{itemize}

Then, there is a list of all \code{unitTests} that were ever run:

\begin{itemize}
\item \code{dateCreated}: Date and time at which this unit test was first run.
\item \code{dateLastRun}: Date and time at which this unit test was last run.
\item \code{name}: Name of the unit test.
\item \code{passing}: Set to true only if there were no failures in the last run.
\end{itemize}

\lstinputlisting[caption={Suite file output.}, label={lst:output:suite}]{snippets/suite.json}

\subsection{Unit Test File}
\label{section:output:unit}

In each unit test file, the results for a test's single run can be found. The exact structure depends on the mixins (see Section~\ref{section:mixins}) the unit test used. Consult the appropriate subsection for each mixins output. Listing~\ref{lst:output:unit} shows the top-level JSON specification of a unit test that used the Compare Mixin and Exception Mixin.

\lstinputlisting[caption={Example unit test file output.}, label={lst:output:unit}]{snippets/unit.json}

\subsection{Custom Output}
\label{section:output:custom}

Custom import and export classes must derive from the \code{IImporter} and \code{IExporter}interfaces. They must be registered before running your tests.

In addition to implementing the interfaces, the classes must also have a static member variable \code{name}. This is the string which users can pass to the \code{-o --output} command line argument to select the output format. For reference, the definition of this variable in the JSON classes looks as follows: \code{static constexpr char name[] = "json";}. The name must be unique. If it is already in use, an exception is thrown on registration.

\subsubsection{Importer}
\label{section:output:custom:importer}

Currently, the importer has just one responsibility: reading the main suite file. For that, two methods need to be implemented.

Firstly, a constructor that takes the path to the output directory, which it should pass on to the \code{IImporter} constructor.

Secondly, the \code{readSuiteFile} method. If a main suite file does not exist because the test suite was never run yet (at least not in the given output directory), nothing should be done and this function should return \code{false}. Otherwise, all relevant data should be retrieved and stored in the \code{SuiteData} and \code{TestDataList} objects, which can all be accessed through the \code{TestSuite} parameter.

\subsubsection{Exporter}
\label{section:output:custom:exporter}

The exporter should write both the main suite file, as well as all unit test results. The built-in exporters write the results for each test to a separate file, but a new exporter is of course completely free in how it does things.

In the \code{writeSuiteFile} method, the \code{SuiteData} and \code{TestDataList} objects should be written to disk.

The \code{writeUnitTestFile} method is responsible for exporting the results of a single test.

The JSON and XML exporters both support multithreading. They write to a different file for each test, so no synchronization is needed. To specify whether or not an exporter supports this, the \code{supportsMultithreading} method must be implemented.

\subsubsection{Registration}
\label{section:output:custom:register}

Registration of custom exporters and importers is straightforward. You only need to call the \code{bt::registerExporter} and \code{bt::registerImporter} functions with your classes as template parameters before calling \code{bt::run}.

\lstinputlisting[caption={.}, label={lst:output:register}]{snippets/register.cpp}